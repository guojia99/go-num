package _1

// 	// 反转
//	for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {
//		nums[i], nums[j] = nums[j], nums[i]
//	}

// nextPermutation
// 整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。
//
// 例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。
// 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的
// 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。
//
// 例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
// 类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
// 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。
// 给你一个整数数组 nums ，找出 nums 的下一个排列。
//
// 必须 原地 修改，只允许使用额外常数空间。
// 链接：https://leetcode.cn/problems/next-permutation

// 如何变大：从低位挑一个大一点的数，交换前面一个小一点的数,变大的幅度要尽量小。
// 像 [3,2,1] 这样递减的，没有下一个排列，已经稳定了，没法变大。
// 像 [1,5,2,4,3,2] 这种，怎么稍微变大？
// 从右往左，寻找第一个比右邻居小的数，把它换到后面去
// “第一个”意味着尽量是低位，“比右邻居小”意味着它是从右往左的第一个波谷
// 比如，1 5 (2) 4 3 2，中间这个 2。
// 接着还是从右往左，寻找第一个比这个 2 大的数。15 (2) 4 (3) 2，交换后：15 (3) 4 (2) 2。
// 还没结束！变大的幅度可以再小一点，仟位微变大了，后三位可以再小一点。
// 后三位肯定是递减的，翻转，变成[1,5,3,2,2,4]，即为所求。
//
// 链接：https://leetcode.cn/problems/next-permutation/solution/jie-fa-hen-jian-dan-jie-shi-qi-lai-zen-yao-jiu-na-/
func nextPermutation(nums []int) {
	// 0、1个或空数组直接返回
	// 1、从右开始往前找变小的数
	// 2、然后从这个数开始从左往右找最小差值的数(找到等值或者边界值为止)
	// 3、然后交换这两个值
	// 4、因为交换完成后, 当前位置往后的子数组是一个降序的数组, 所以要保证最小变化需要做一次反转
	// e.g.
	// 定位[1,5,(2),4,3,2] -> 找最小差[1,5,(2),4,(3),2] -> 交换[1,5,(3),4,(2),2] -> 反转[1,5,3,(4,2,2)] -> [1,5,3,2,2,4]

	if len(nums) <= 1 {
		return
	}
	// 1. 指针(l) 从右向左开始出发, 前面的指针如果比后面的指针大的话, 就需要一直找下去
	var l = len(nums) - 2
	for l >= 0 && nums[l] >= nums[l+1] {
		l--
	}

	// 2. 找到之后从前指针的位置作为一个哨兵指针(l), 即这个位置往左找到一个差值最小的交换指针(r)
	var r = len(nums) - 1
	if l >= 0 {
		for r > 0 && nums[r] <= nums[l] {
			r--
		}
		nums[l], nums[r] = nums[r], nums[l]
	}

	// 3.反转哨兵指针(l)后的所有值
	i, j := l+1, len(nums)-1
	for i < j {
		nums[i], nums[j] = nums[j], nums[i]
		i++
		j--
	}
}
