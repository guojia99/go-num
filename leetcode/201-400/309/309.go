package _09

// 309. 最佳买卖股票时机含冷冻期
// 给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。
//
// 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
//
// 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
// 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
//
// 示例 1:
//
// 输入: prices = [1,2,3,0,2]
// 输出: 3
// 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
// 示例 2:
//
// 输入: prices = [1]
// 输出: 0
//
// 提示：
//
// 1 <= prices.length <= 5000
// 0 <= prices[i] <= 1000
func maxProfit(prices []int) int {
	if len(prices) <= 1 {
		return 0
	}
	max := func(a, b int) int {
		if a > b {
			return a
		}
		return b
	}
	// dp[i][0] 不持股，未卖出 (state 0) | dp[i][1] 持股 (state 1) | dp[i][2]不持股，且昨天卖出了 (state 2)
	var dp = make([][3]int, len(prices))
	dp[0] = [3]int{0, -prices[0], 0}

	// 第i天的状态分析
	for i := 1; i < len(prices); i++ {
		// 1、不持股，未卖出的情况。第i天未持股，且也没卖出的情况下，说明第i-1天也没有股票可以持有.
		//    - 昨天未持股票且没卖出(0)，昨天持有股票了且卖出了(2)
		dp[i][0] = max(dp[i-1][0], dp[i-1][2])
		// 2、 持股了。 两种情况，今天刚买入 或者 昨天已经持有股票了。
		//    - 此时今天刚买入的情况，昨天并没有卖出去(冷却期限制), 所以昨天只有可能是(0) -> (1), 所以拿昨天的收益减去今天买入的价格来作为收益。
		//	  - 昨天已经有股票了，那今天就继承昨天的即可。(1) -> (1)
		dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])
		// 3、 不持股，今天是卖出的情况。
		// 	  - 只有一种情况， 昨天是持股的 (1), 所以今天的收益就是卖出股票。(1) -> (2)
		dp[i][2] = dp[i-1][1] + prices[i]
	}
	// 最后一天, 只可能是不持有股票的才有收益, 对比一下两种情况即可。
	return max(dp[len(prices)-1][0], dp[len(prices)-1][2])
}
