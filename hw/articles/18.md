---
title: '18 识别有效的IP地址和掩码并进行分类统计'
tags:
- 字符串
- 查找
---

## 描述

请解析IP地址和对应的掩码，进行分类识别。要求按照A/B/C/D/E类地址归类，不合法的地址和掩码单独归类。

所有的IP地址划分为 A,B,C,D,E五类

A类地址1.0.0.0~126.255.255.255;

B类地址128.0.0.0~191.255.255.255;

C类地址192.0.0.0~223.255.255.255;

D类地址224.0.0.0~239.255.255.255；

E类地址240.0.0.0~255.255.255.255



私网IP范围是：

10.0.0.0-10.255.255.255

172.16.0.0-172.31.255.255

192.168.0.0-192.168.255.255

子网掩码为二进制下前面是连续的1，然后全是0。（例如：255.255.255.32就是一个非法的掩码）

（注意二进制下全是1或者全是0均为非法子网掩码）

注意：

\1. 类似于【0.*.*.*】和【127.*.*.*】的IP地址不属于上述输入的任意一类，也不属于不合法ip地址，计数时请忽略

\2. 私有IP地址和A,B,C,D,E类地址是不冲突的



### 输入描述：

多行字符串。每行一个IP地址和掩码，用~隔开。

### 输出描述：

统计A、B、C、D、E、错误IP地址或错误掩码、私有IP的个数，之间以空格隔开。

## 示例1

输入：

```
10.70.44.68~255.254.255.0
1.0.0.1~255.0.0.0
192.168.0.2~255.255.255.0
19..0.~255.255.255.0
```



输出：

```bash
1 0 1 0 0 2 1
```



说明：

```
10.70.44.68~255.254.255.0的子网掩码非法，19..0.~255.255.255.0的IP地址非法，所以错误IP地址或错误掩码的计数为2；
1.0.0.1~255.0.0.0是无误的A类地址；
192.168.0.2~255.255.255.0是无误的C类地址且是私有IP；
所以最终的结果为1 0 1 0 0 2 1  
```

## 示例2

输入：

```
0.201.56.50~255.255.111.255
127.201.56.50~255.255.111.255
```



输出：

```bash
0 0 0 0 0 0 0
```



说明：

```bash
类似于【0.*.*.*】和【127.*.*.*】的IP地址不属于上述输入的任意一类，也不属于不合法ip地址，计数时请忽略   
```

## 思路

- 使用一个结果数组保存计数
- 创建检查辅助函数，逐一更新结果

## 代码

> 此代码仅供参考，并未通过全部测试用例（或许是某个逻辑错误），测试用例难以调试。

```js
const res = [0, 0, 0, 0, 0, 0, 0]; // A B C D E 错误地址或掩码 私有地址

const isValidMask = (maskStr) => {
  return (
    isValidAddr(maskStr) &&
    /^1+0+$/.test(
      maskStr
        .split(".")
        .map((i) => Number(i).toString(2))
        .join("")
    )
  );
};

const isValidAddr = (str) => {
  const arr = str.split(".");
  if (arr.length !== 4) return false;
  return arr.every((i) => {
    return i.length > 0 && i.length < 4 && !/^0\d+/.test(i) && ~~i < 266;
  });
};

const isPrivateAddr = (str) => {
  const [a, b] = str.split(".").map(Number);
  return (
    a === 10 || (a === 172 && b >= 16 && b <= 31) || (a === 192 && b === 168)
  );
};

const getAddrClassTypeIdx = (str) => {
  const [a] = str.split(".").map(Number);
  if (a >= 1 && a <= 126) return 0;
  if (a >= 128 && a <= 191) return 1;
  if (a >= 192 && a <= 223) return 2;
  if (a >= 224 && a <= 239) return 3;
  if (a >= 240 && a <= 255) return 4;
};

while ((input = readline())) {
  const [ipStr, maskStr] = input.split("~");
  // 忽略特殊地址
  if (!ipStr.startsWith("0.") && !ipStr.startsWith("127.")) {
    // 检查是否错误的地址或掩码
    if (!isValidAddr(ipStr) || !isValidMask(maskStr)) {
      res[5] += 1;
    } else {
      // 检查地址类别和类型
      if (isPrivateAddr(ipStr)) {
        res[6] += 1;
      }
      // 私有地址和地址类不冲突
      res[getAddrClassTypeIdx(ipStr)] += 1;
    }
  }
}

console.log(res.join(" "));

```

